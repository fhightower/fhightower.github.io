<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interface Design on Floyd</title><link>https://hightower.space/tags/interface-design/</link><description>Recent content in Interface Design on Floyd</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 18 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://hightower.space/tags/interface-design/index.xml" rel="self" type="application/rss+xml"/><item><title>Interface Driven Design</title><link>https://hightower.space/posts/interface-drive-design/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://hightower.space/posts/interface-drive-design/</guid><description>&lt;p>When designing a system with many components which must interact, the primary challenge is getting the components to interact effectively. Typically, each component has a clear set of responsibilities and building it is relatively easy. The difficulty comes when you need to talk to another component.&lt;/p>
&lt;p>In this blog post, I advocate for a design approach I call &amp;ldquo;Interface Driven Design&amp;rdquo; and provide a framework for applying Interface Driven Design when designing (or trying to understand) a system.&lt;/p>
&lt;h2 id="why-is-interface-driven-design-useful">Why is Interface Driven Design Useful?&lt;/h2>
&lt;p>When designing complex systems made up of many components in communication, the most error-prone location is often in the system interfaces (at the component boundaries).
Interface Driven Design helps designers focus on one of the most challenging areas of system design. It also makes it easy for teams building different components to collaborate effectively.&lt;/p>
&lt;h3 id="when-is-interface-driven-design-useful">When is Interface Driven Design Useful?&lt;/h3>
&lt;p>Generally, it is useful in systems with at least two of the following:&lt;/p>
&lt;ul>
&lt;li>With many components which communicate with each other&lt;/li>
&lt;li>Being built by multiple teams&lt;/li>
&lt;li>Microservices which are each relatively simple, but form a complex system with emergent behaviour&lt;/li>
&lt;/ul>
&lt;h2 id="how-to-apply-interface-driven-design">How to Apply Interface Driven Design?&lt;/h2>
&lt;p>Interface Driven Design can be applied at multiple levels.
For the sake of this article, we&amp;rsquo;ll apply it at the level of each component of a mircoservice system.
I like to use the following framework to think about each component:&lt;/p>
&lt;ol>
&lt;li>Triggers
&lt;ul>
&lt;li>This section should include which systems/event trigger the component as well as what data gets sent to the component&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Side-effects
&lt;ul>
&lt;li>This section includes any side-effects which are performed by the component (e.g. writing to a DB or triggering another component)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Errors/Failures
&lt;ul>
&lt;li>This section details the errors this component may raise/return (usually just the ones that the component will intentionally raise/return)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Response(s)
&lt;ul>
&lt;li>This section documents the response(s) the component gives to the various triggers&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>GUI vs. UI</title><link>https://hightower.space/posts/gui-vs-ui/</link><pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate><guid>https://hightower.space/posts/gui-vs-ui/</guid><description>&lt;p>I believe words are important.&lt;sup>1&lt;/sup> I recently caught myself saying something I consider dangerous for the way we think about computing and programming. I found my self saying &amp;ldquo;UI&amp;rdquo; (which is short for &amp;ldquo;User Interface&amp;rdquo;) to describe a &amp;ldquo;GUI&amp;rdquo; (a &amp;ldquo;Graphical User Interface&amp;rdquo;). UI is a broad category which encompasses multiple ways a user may interface with a system. A GUI is a specific instance of UI which relies on &amp;lsquo;visual metaphors&amp;rsquo; to communicate information to a user and allow the user to interact with the underlying system (the most ubiquitous example of a GUI is a website).&lt;/p>
&lt;aside class="marginnote">
&lt;span class="noteNumber">1&lt;/span> - I've started inventing my own words &lt;a href="https://hightower.space/thoughts/my-words/" target="_blank">here&lt;/a>
&lt;/aside>
&lt;p>When I use &amp;lsquo;UI&amp;rsquo; to describe a GUI, I&amp;rsquo;m limiting the definition of UI only to GUIs.&lt;sup>2&lt;/sup> Shrinking the definition of UI is dangerous because it makes it easy for us to forget about all of the other ways users interface with a system. A CLI (Command Line Interface) or API (Application Programming Interface) is just as much a UI as a GUI. All interfaces with a system should be as user-friendly as possible and the first step to accomplish this is to recognize all of the ways a user interfaces with a system.&lt;/p>
&lt;aside class="marginnote">
&lt;span class="noteNumber">2&lt;/span> - In this instance, "UI" is something that I call a &lt;a href="https://hightower.space/thoughts/my-words#Lamech" target="_blank">Lamech&lt;/a>
&lt;/aside></description></item></channel></rss>