<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Exponentials on Floyd</title><link>https://hightower.space/tags/exponentials/</link><description>Recent content in Exponentials on Floyd</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 17 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://hightower.space/tags/exponentials/index.xml" rel="self" type="application/rss+xml"/><item><title>Orders of Magnitude Scoring System</title><link>https://hightower.space/posts/orders-of-mag-scoring-system/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://hightower.space/posts/orders-of-mag-scoring-system/</guid><description>&lt;p>While this idea is original to me, I am confident I am not the first person to come up with this idea.
I have not, however, been able to find this idea mentioned anywhere (after a cursory search).&lt;/p>
&lt;h2 id="the-use-case">The Use-Case&lt;/h2>
&lt;p>There are cases in which using counting numbers for a scoring system does not work because the difference between n and n+1
are not sufficiently differentiated. For example, in a scoring system that seeks to score books based on the number of years one
would wait before reading a book again, the difference between waiting 6 versus 7 years to read a book again is trivial making it
hard for scoring a book to choose a reasonable number.&lt;/p>
&lt;h2 id="the-scoring-system">The Scoring System&lt;/h2>
&lt;p>My &amp;ldquo;Orders of Magnitude Scoring System&amp;rdquo; requires that the n+1-th score be an order of magnitude larger than the n-th score.
Perhaps the simplest such system for our base-ten minds uses the number 10 as the base.
The possible scores of this system will be:&lt;/p>
&lt;ul>
&lt;li>1 (10^0)&lt;/li>
&lt;li>10 (10^1)&lt;/li>
&lt;li>100 (10^2)&lt;/li>
&lt;li>1000 (10^3) &amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>Thinking back to our example about a scoring system for books in which one provides the number of years one
would wait before reading a book again, I think it is easy to see how this scoring system is easier to use as it avoids the challenge
of differentiating adjacent values (e.g. 6 versus 7 years).&lt;/p>
&lt;p>Another use case where I&amp;rsquo;ve found this system helpful is capturing how long one estimates a task to take.
When making such estimates, it is hard to estimate the difference between 6 or 7 hours (or 50 vs. 60 hours),
but using scores which are orders of magnitude different from one another make this task much easier
(assuming you can tolerate the loss of precision when having to round to the nearest option).
I use an order of magnitude system to estimate time cost for issues in the
&lt;a href="https://github.com/fhightower/ioc-finder/labels?q=time">ioc-finder&lt;/a> project, for example.&lt;/p>
&lt;h2 id="similar-systems">Similar Systems&lt;/h2>
&lt;p>This kind of scoring system is a subset of what could be called &amp;ldquo;Exponentially Scaled Scoring Systems&amp;rdquo; where the n+1-th score must be exponentially larger than the n-th score.&lt;/p></description></item><item><title>Domain Squatting Math</title><link>https://hightower.space/posts/math-behind-domain-squatting/</link><pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate><guid>https://hightower.space/posts/math-behind-domain-squatting/</guid><description>&lt;blockquote>
&lt;p>&amp;ldquo;Compound interest is the eighth wonder of the world. He who understands it, earns it &amp;hellip; he who doesn&amp;rsquo;t &amp;hellip; pays it.&amp;rdquo;&lt;/p>
&lt;p>― Albert Einstein&lt;/p>
&lt;/blockquote>
&lt;h2 id="what-is-domain-squatting">What is domain squatting?&lt;/h2>
&lt;p>Domain squatting is when someone registers a domain name which looks like another domain name. Usually, the term &amp;ldquo;domain squatting&amp;rdquo; is used in a context where malicious intent is implied. For example, someone trying to steal passwords may register the domain name &lt;code>gooogle.com&lt;/code> (with an extra &lt;code>o&lt;/code> in it). This way, he/she could send emails to potential victims with links to &lt;code>gooogle.com&lt;/code> and the potential victims would be more likely to mistake this domain for the real thing and click the links.&lt;/p>
&lt;h2 id="the-math-of-domain-squatting">The math of domain squatting&lt;/h2>
&lt;p>The are &lt;a href="https://github.com/xn-twist/xn-twist">numerous&lt;/a> &lt;a href="https://github.com/elceef/dnstwist">algorithms&lt;/a> available to find domain squats for a given domain, but the difficulty is that finding domain squats for a given domain is computationally difficult and demonstrates exponential growth. Let&amp;rsquo;s examine this a bit more.&lt;/p>
&lt;p>For starters, how many possible domain squats are there for &lt;code>abc.com&lt;/code>? Let&amp;rsquo;s assume the &lt;a href="https://en.wikipedia.org/wiki/Top-level_domain">top level domain&lt;/a> (e.g. &lt;code>.com&lt;/code>) remains the same - we&amp;rsquo;ll just focus on the &lt;code>abc&lt;/code> bit. Let&amp;rsquo;s also pretend that there are two characters which can replace each of the characters in &lt;code>abc&lt;/code>. In other words, we can replace &lt;code>a&lt;/code> with &lt;code>а&lt;/code> (a character from the Cyrillic alphabet) or &lt;code>α&lt;/code> (a character from the Greek alphabet) and we can replace both &lt;code>b&lt;/code> and &lt;code>c&lt;/code> with two other characters as well. So, for each character in &lt;code>abc&lt;/code>, we have three options:&lt;/p>
&lt;ol>
&lt;li>Replace it with the first option&lt;/li>
&lt;li>Replace it with the second option&lt;/li>
&lt;li>Keep it the same&lt;/li>
&lt;/ol>
&lt;p>For each character, we have the three options we listed above, so all possible combinations amount to: &lt;code>3 * 3 * 3 = 27&lt;/code>. But, one of the twenty seven configurations is one in which all of the characters in the original domain are kept the same. Because this does not constitute a domain squat, we remove this one to get &lt;code>26&lt;/code> as our final answer. A domain with three characters and an average of two replacements per character can produce twenty six domain squats!&lt;/p>
&lt;p>We can represent the number of domain squats formulaically as:&lt;/p>
&lt;pre tabindex="0">&lt;code>((r + 1) ^ n) - 1
&lt;/code>&lt;/pre>&lt;p>where&lt;/p>
&lt;ul>
&lt;li>&lt;code>r&lt;/code> is the number of characters which can replace each character in the domain&lt;/li>
&lt;li>&lt;code>n&lt;/code> is number of characters in the domain&lt;/li>
&lt;/ul>
&lt;p>Thus, the number of possible replaces for a domain name that is 10 characters long assuming we can replace each character with 10 other characters is: &lt;code>((10 + 1) ^ 10) - 1 = (11 ^ 10) - 1 = 25,937,424,600&lt;/code>. 25 &lt;strong>billion&lt;/strong> possible domain squats! This is the challenge of finding domain squats; it is a system that grows exponentially. What if we keep everything the same, but find domain squats for a domain which is 11 characters long? That works out to be: &lt;code>10 ^ 11 = 285,311,670,610&lt;/code>. 285 &lt;strong>billion&lt;/strong>! If you were to plot 25 billion on a number line stretching between zero and 285 billion, it would look something like:&lt;/p>
&lt;p>&lt;code>0....|............................................285,000,000,000&lt;/code>&lt;/p>
&lt;p>Adding one more character to our domain name, we have exponentially increased the possible squats.&lt;/p>
&lt;p>Below is some &lt;a href="https://clojure.org/api/cheatsheet">clojure&lt;/a> code you can play with to find the number of domain squats for domains of various lengths. Notice that adding one character to a domain&amp;rsquo;s length increases the amount of time required to find all domain squats exponentially (non-linearly)!&lt;/p>
&lt;link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
&lt;script>
window.klipse_settings = {
selector: '.language-klipse'
};
&lt;/script>
&lt;pre>&lt;code class="language-klipse">
(defn pow [n x]
(reduce * (repeat x n)))
(defn possible-domain-squats [domain-length avg-replacement-chars]
(dec (pow (inc avg-replacement-chars) domain-length)))
; change the values below to see how the possible domain squats change
(def domain-length 10)
(def avg-replacement-chars 10)
(possible-domain-squats domain-length avg-replacement-chars)
&lt;/code>&lt;/pre>
&lt;p>Here is another way to systematically observe how the number of domain squats changes with the size of the domain name. We assume ten replacement characters (that is, each character in the domain can be replaced with ten characters - which is very reasonable) for domains of varying lengths:&lt;/p>
&lt;pre>&lt;code class="language-klipse">
(for [domain-length (range 3 16)
:let [squats (possible-domain-squats domain-length 10)]]
{:domain-length domain-length :squats squats})
&lt;/code>&lt;/pre>
&lt;script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js">&lt;/script></description></item></channel></rss>